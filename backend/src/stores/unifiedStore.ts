/**
 * @fileoverview Unified data store for Foodbank Check-In and Appointment System backend API
 * 
 * This module provides a centralized data store that manages all check-in data,
 * client information, and appointment scheduling. It handles data persistence,
 * retrieval, and provides timezone-aware date operations for the Vancouver timezone.
 * 
 * @author Lindsey D. Stead
 * @version 1.0.0
 * @since 2025-10-20
 * @license Proprietary - see LICENSE file for details
 * 
 * @see {@link ../controllers/checkInController.ts} Check-in controller
 */

import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';

dayjs.extend(utc);
dayjs.extend(timezone);

const VANCOUVER_TZ = 'America/Vancouver';

/**
 * Get current time as ISO string
 */
const getCurrentTimeISO = (): string => {
  return new Date().toISOString();
};

// Unified record interface
export interface UnifiedRecord {
  id: string;
  clientId: string;
  clientName: string;
  phoneNumber: string;
  checkInTime: string;
  appointmentTime?: string;
  status: 'Pending' | 'Shipped' | 'Collected' | 'Not Collected' | 'Rescheduled' | 'Cancelled';
  source: 'csv' | 'manual' | 'api';
  
  // Client data
  firstName?: string;
  lastName?: string;
  email?: string;
  dietaryConsiderations?: string;
  householdSize?: number;
  adults?: number;
  seniors?: number;
  children?: number;
  childrensAges?: string;
  childrenAges?: string; // Alternative naming
  itemsProvided?: string;
  notes?: string;
  phoneDigits?: string; // For phone number matching
  
  // Check-in completion data
  completionTime?: string;
  dietaryRestrictions?: string[];
  allergies?: string;
  unwantedFoods?: string;
  additionalInfo?: string;
  householdInfoChanged?: boolean;
  hasMobilityIssues?: boolean;
  diaperSize?: string;
  notificationPreference?: string;
  phone?: string;
  phoneCarrier?: string;
  location?: string;
  program?: string; // Link2Feed Program field (e.g., Food Hamper, Emergency Support)
  clientType?: string;
  waitTime?: number; // minutes
  
  // Appointment data
  pickUpDate?: string;
  pickUpTime?: string; // HH:MM format (e.g., "09:00", "14:30")
  pickUpISO?: string;
  provisions?: string;
  quantity?: number;
  
  // Next appointment data
  nextAppointmentDate?: string;
  nextAppointmentTime?: string;
  nextAppointmentISO?: string;
  ticketNumber?: string;
  isAutoGenerated?: boolean;
  generatedFrom?: string;
  generatedAt?: string;
  
  // Metadata
  createdAt: string;
  updatedAt: string;
  expiresAt: string;
}

// In-memory storage - all data lives here
// TODO: Could migrate to Redis for production scale, but in-memory works fine for nowor supa
const records = new Map<string, UnifiedRecord>();
const dailyData = new Map<string, { csvRecords: UnifiedRecord[], expiresAt: string }>();
const helpRequests = new Map<number, any>(); // Store help requests: id -> request data

// Data version for frontend sync - increments on changes so UI can detect updates
let dataVersion = 0;
let helpRequestIdCounter = 1;

// Simple daily counters for analytics
const dailyCounters = new Map<string, {
  totalAppointments: number;
  completedCheckIns: number;
  expiresAt: string;
}>();

/**
 * Get today's key in YYYY-MM-DD format in Vancouver timezone
 * Always use Vancouver time for consistency - important for daily operations
 */
export const todayKey = (): string => {
  return dayjs().tz(VANCOUVER_TZ).format('YYYY-MM-DD');
};

/**
 * Get expiry time 24 hours from now in ISO format
 */
export const expiry24hISO = (): string => {
  return dayjs().add(24, 'hours').toISOString();
};

/**
 * Check if an ISO date string is today in Vancouver timezone
 */
export const isTodayISO = (iso: string): boolean => {
  const date = dayjs(iso).tz(VANCOUVER_TZ);
  const today = dayjs().tz(VANCOUVER_TZ);
  return date.format('YYYY-MM-DD') === today.format('YYYY-MM-DD');
};

/**
 * Remove expired entries
 * Runs automatically to keep memory footprint low
 * Data expires after 24 hours
 */
export const purgeExpired = (): void => {
  const now = dayjs().toISOString();
  let dataChanged = false;
  
  // Purge individual records
  for (const [id, record] of records.entries()) {
    if (record.expiresAt < now) {
      records.delete(id);
      dataChanged = true;
    }
  }
  
  // Purge daily data
  for (const [key, data] of dailyData.entries()) {
    if (data.expiresAt < now) {
      dailyData.delete(key);
      dataChanged = true;
    }
  }
  
  // Increment version if data was purged - triggers frontend refresh
  if (dataChanged) {
    dataVersion++;
  }
};

/**
 * Store CSV data (just CSV records with pickup times)
 * Returns deduplication stats
 */
export const storeCSVData = (csvRecords: any[], importId: string): { total: number; added: number; duplicates: number } => {
  // Use the pickup date from the first CSV record as the key, not today's date
  let key = todayKey(); // Default to today
  if (csvRecords.length > 0 && csvRecords[0].pickUpISO) {
    // Extract date directly from ISO string to avoid timezone conversion issues
    // Format: "2025-10-27T09:00:00-07:00"
    const isoString = csvRecords[0].pickUpISO;
    const match = isoString.match(/(\d{4}-\d{2}-\d{2})/);
    if (match) {
      key = match[1]; // Use the date part directly
    }
  }
  const expiresAt = expiry24hISO();
  
  // Get existing records to check for duplicates
  const existingRecords = Array.from(records.values()).filter(r => r.source === 'csv');
  const existingLookup = new Map<string, UnifiedRecord>();
  
  // Create lookup: clientId + appointmentTime for deduplication
  // This prevents the same CSV from being imported twice and creating dupes
  existingRecords.forEach(record => {
    // Use appointmentTime for deduplication (key field), normalize to ensure consistent comparison
    const apptTime = (record.appointmentTime || '').toString();
    const dedupeKey = `${record.clientId}_${apptTime}`;
    existingLookup.set(dedupeKey, record);
  });
  
  let duplicates = 0;
  let added = 0;
  
  // Store CSV records as "Pending" status (not checked in yet)
  const unifiedRecords: UnifiedRecord[] = [];
  
  csvRecords.forEach(record => {
    // Use pickUpISO which gets mapped to appointmentTime (same value)
    // Normalize the ISO string to ensure consistent comparison
    const apptTime = record.pickUpISO || '';
    const dedupeKey = `${record.clientId}_${apptTime}`;
    
    // Determine correct initial status by comparing current Vancouver time vs appointment time
    // Auto-detect missed appointments on CSV import
    let initialStatus: 'Pending' | 'Not Collected' = 'Pending';
    const nowVancouver = dayjs().tz(VANCOUVER_TZ);
    
    if (apptTime) {
      const appointmentTime = dayjs(apptTime).tz(VANCOUVER_TZ);
      const minutesSinceAppointment = nowVancouver.diff(appointmentTime, 'minute');
      
      // If appointment was more than 30 minutes ago, mark as "Not Collected"
      // This auto-flags late/missed appointments when CSV is uploaded after their slot
      if (minutesSinceAppointment > 30) {
        initialStatus = 'Not Collected';
      }
    }
    
    // Check if this record already exists
    if (!existingLookup.has(dedupeKey)) {
      unifiedRecords.push({
        id: `csv_${record.clientId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        clientId: record.clientId,
        clientName: `${record.firstName} ${record.lastName}`.trim(),
        phoneNumber: record.phoneNumber,
        checkInTime: '', 
        appointmentTime: apptTime, // This is the pickup time from CSV
        status: initialStatus, // Auto-set based on Vancouver time vs appointment time
        source: 'csv',
        firstName: record.firstName,
        lastName: record.lastName,
        email: record.email,
        dietaryConsiderations: record.dietaryConsiderations,
        householdSize: record.householdSize,
        adults: record.adults,
        seniors: record.seniors,
        children: record.children,
        childrensAges: record.childrensAges,
        itemsProvided: record.itemsProvided,
        pickUpDate: record.pickUpDate,
        pickUpTime: record.pickUpTime, // HH:MM format from CSV (e.g., "09:00", "14:30")
        pickUpISO: record.pickUpISO,
        provisions: record.provisions,
        quantity: record.quantity,
        location: record.location,
        program: record.program,
        createdAt: record.createdAt || getCurrentTimeISO(),
        updatedAt: getCurrentTimeISO(),
        expiresAt
      });
      added++;
    } else {
      duplicates++;
    }
  });
  
  // Store in daily data (append new records to existing ones if any)
  const existingDailyData = dailyData.get(key);
  const combinedRecords = existingDailyData 
    ? [...existingDailyData.csvRecords, ...unifiedRecords]
    : unifiedRecords;
  
  dailyData.set(key, {
    csvRecords: combinedRecords,
    expiresAt
  });
  
  // Store individual records for easy access
  unifiedRecords.forEach(record => records.set(record.id, record));
  
  // Update counters (add to existing count)
  const existingCounters = dailyCounters.get(key);
  const totalAppointments = (existingCounters?.totalAppointments || 0) + unifiedRecords.length;
  
  dailyCounters.set(key, {
    totalAppointments,
    completedCheckIns: existingCounters?.completedCheckIns || 0,
    expiresAt
  });
  
  return { total: csvRecords.length, added, duplicates };
};

/**
 * Add a check-in record
 */
export const addCheckIn = (checkInData: Partial<UnifiedRecord>): UnifiedRecord => {
  const id = `checkin_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const now = getCurrentTimeISO();
  
  const record: UnifiedRecord = {
    id,
    clientId: checkInData.clientId || 'unknown',
    clientName: checkInData.clientName || 'Unknown Client',
    phoneNumber: checkInData.phoneNumber || '',
    checkInTime: checkInData.checkInTime || now,
    appointmentTime: checkInData.appointmentTime,
    status: checkInData.status || 'Pending',
    source: checkInData.source || 'manual',
    createdAt: now,
    updatedAt: now,
    expiresAt: expiry24hISO(),
    ...checkInData
  };
  
  records.set(id, record);
  return record;
};

/**
 * Update a check-in record
 */
export const updateCheckIn = (id: string, updates: Partial<UnifiedRecord>): UnifiedRecord | null => {
  const record = records.get(id);
  if (!record) return null;
  
  const updatedRecord = {
    ...record,
    ...updates,
    updatedAt: getCurrentTimeISO()
  };
  
  records.set(id, updatedRecord);
  
  // Also update the record in dailyData to keep them in sync
  const today = todayKey();
  const dailyDataEntry = dailyData.get(today);
  if (dailyDataEntry) {
    const csvRecords = dailyDataEntry.csvRecords;
    const recordIndex = csvRecords.findIndex(r => r.id === id);
    if (recordIndex !== -1) {
      csvRecords[recordIndex] = updatedRecord;
      dailyData.set(today, {
        csvRecords,
        expiresAt: dailyDataEntry.expiresAt
      });
    }
  }
  
  return updatedRecord;
};

/**
 * Get check-in by ID
 */
export const getCheckInById = (id: string): UnifiedRecord | null => {
  return records.get(id) || null;
};

/**
 * Get all check-ins
 */
export const getAllCheckIns = (): UnifiedRecord[] => {
  // Auto-update missed appointments before returning
  autoUpdateMissedAppointments();
  return Array.from(records.values());
};

/**
 * Get check-ins by status
 * KEPT FOR FUTURE LINK2FEED INTEGRATION
 * Currently unused but may be needed when integrating with Link2Feed API
 */
// export const getCheckInsByStatus = (status: 'Pending' | 'Shipped' | 'Collected' | 'Not Collected' | 'Rescheduled' | 'Cancelled'): UnifiedRecord[] => {
//   // Auto-update missed appointments before returning
//   autoUpdateMissedAppointments();
//   return Array.from(records.values()).filter(record => record.status === status);
// };

/**
 * Automatically update missed appointments (Pending status where appointment time has passed)
 * Only runs checks once every 5 minutes to avoid excessive logging
 */
let lastAutoUpdateTime = 0;
const AUTO_UPDATE_INTERVAL = 5 * 60 * 1000; // 5 minutes

const autoUpdateMissedAppointments = (): void => {
  const now = Date.now();
  
  // Only run auto-update every 5 minutes to avoid excessive logging
  if (now - lastAutoUpdateTime < AUTO_UPDATE_INTERVAL) {
    return;
  }
  
  lastAutoUpdateTime = now;
  let updated = false;

  for (const [id, record] of records.entries()) {
    // Only check Pending appointments with an appointment time AND no check-in time
    if (record.status === 'Pending' && record.appointmentTime && !record.checkInTime) {
      const appointmentTime = new Date(record.appointmentTime).getTime();
      
      // If appointment time has passed (more than 30 minutes ago) AND no check-in, mark as "Not Collected"
      // This matches the check-in rejection logic (30 minutes late)
      const thirtyMinutesAgo = now - (30 * 60 * 1000); // 30 minutes in milliseconds
      
      if (appointmentTime < thirtyMinutesAgo) {
        record.status = 'Not Collected';
        record.updatedAt = getCurrentTimeISO();
        records.set(id, record);
        updated = true;
      }
    }
  }

  // Update data version if any changes were made
  if (updated) {
    dataVersion++;
  }
};

/**
 * Get today's CSV records (with pickup times)
 * Only returns records for the exact current date in Vancouver timezone
 * Returns empty array if no data exists for today
 */
export const getTodayAppointments = (): UnifiedRecord[] => {
  // Auto-update missed appointments before returning
  autoUpdateMissedAppointments();
  
  const key = todayKey();
  const data = dailyData.get(key);
  
  if (!data) {
    // Log for debugging but don't fall back to old/incorrect data
    if (dailyData.size > 0) {
      const availableDates = Array.from(dailyData.keys()).join(', ');
      console.warn(`No data found for today (${key}). Available dates: ${availableDates}`);
    }
    return [];
  }
  
  return data.csvRecords;
};

/**
 * Get appointments for a specific date
 * KEPT FOR FUTURE LINK2FEED INTEGRATION
 */
// export const getAppointmentsForDate = (date: string): UnifiedRecord[] => {
//   const data = dailyData.get(date);
//   return data ? data.csvRecords : [];
// };

/**
 * Get today's clients
 * KEPT FOR FUTURE LINK2FEED INTEGRATION
 * This is just a wrapper for getTodayAppointments - kept in case Link2Feed needs it
 */
// export const getTodayClients = (): UnifiedRecord[] => {
//   return getTodayAppointments();
// };

/**
 * Get simple analytics counters for today
 */
export const getTodayAnalytics = (): { totalAppointments: number; completedCheckIns: number; pendingCheckIns: number } => {
  // First try today's date
  let key = todayKey();
  let counters = dailyCounters.get(key);
  
  // If no data for today, try to find any available data (for different pickup dates)
  if (!counters) {
    for (const [dateKey, data] of dailyCounters.entries()) {
      if (data.totalAppointments > 0) {
        key = dateKey;
        counters = data;
        break;
      }
    }
  }
  
  if (!counters) {
    return { totalAppointments: 0, completedCheckIns: 0, pendingCheckIns: 0 };
  }
  
  return {
    totalAppointments: counters.totalAppointments,
    completedCheckIns: counters.completedCheckIns,
    pendingCheckIns: counters.totalAppointments - counters.completedCheckIns
  };
};

/**
 * Increment completed check-ins counter
 */
export const incrementCompletedCheckIns = (): void => {
  // First try today's date
  let key = todayKey();
  let counters = dailyCounters.get(key);
  
  // If no data for today, try to find any available data (for different pickup dates)
  if (!counters) {
    for (const [dateKey, data] of dailyCounters.entries()) {
      if (data.totalAppointments > 0) {
        key = dateKey;
        counters = data;
        break;
      }
    }
  }
  
  if (counters) {
    counters.completedCheckIns += 1;
    dailyCounters.set(key, counters);
  }
};

/**
 * Find CSV record by phone and last name
 * KEPT FOR FUTURE LINK2FEED INTEGRATION
 */
// export const findClient = (phoneNumber: string, lastName: string): UnifiedRecord | null => {
//   const normalizedLastName = lastName.toLowerCase().trim();
//   const phoneDigits = phoneNumber.replace(/\D/g, '');
//   
//   const records = getTodayAppointments();
//   return records.find(record => 
//     record.phoneNumber.replace(/\D/g, '') === phoneDigits &&
//     record.lastName?.toLowerCase().trim() === normalizedLastName
//   ) || null;
// };

/**
 * Find CSV record by client ID
 * KEPT FOR FUTURE LINK2FEED INTEGRATION
 */
// export const findAppointment = (clientId: string): UnifiedRecord | null => {
//   const records = getTodayAppointments();
//   return records.find(record => 
//     record.clientId === clientId
//   ) || null;
// };

/**
 * Get daily data status
 */
export const getDailyStatus = () => {
  const key = todayKey();
  const data = dailyData.get(key);
  
  // Only return CSV date if data actually exists
  let csvDate: string | undefined = undefined;
  if (data && data.csvRecords.length > 0) {
    const firstRecord = data.csvRecords[0];
    // Try to get the actual date from the record
    if (firstRecord.pickUpDate) {
      csvDate = firstRecord.pickUpDate.split('T')[0];
    } else if (firstRecord.pickUpISO) {
      // Extract from ISO format: 2025-10-27T09:00:00-07:00
      const match = firstRecord.pickUpISO.match(/(\d{4}-\d{2}-\d{2})/);
      if (match) {
        csvDate = match[1];
      }
    }
  }
  
  return {
    today: todayKey(), // Always show today's date for comparison
    csvDate: csvDate, // Only set if CSV data exists
    data: {
      present: !!data,
      count: data ? data.csvRecords.length : 0,
      expiresAt: data?.expiresAt
    }
  };
};

/**
 * Get current data version
 */
export const getDataVersion = (): number => {
  return dataVersion;
};

/**
 * Clear all data
 */
export const clearAllData = (): void => {
  records.clear();
  dailyData.clear();
  helpRequests.clear();
  dataVersion++; // Increment version when data is cleared
};

// Help request storage functions
export const addHelpRequest = (request: any): any => {
  const id = helpRequestIdCounter++;
  const helpRequest = {
    id,
    ...request,
    status: 'pending',
    created_at: getCurrentTimeISO()
  };
  helpRequests.set(id, helpRequest);
  return helpRequest;
};

export const getAllHelpRequests = (): any[] => {
  return Array.from(helpRequests.values()).sort((a, b) => 
    new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
  );
};

export const updateHelpRequestStatus = (id: number, status: string): boolean => {
  const request = helpRequests.get(id);
  if (request) {
    request.status = status;
    helpRequests.set(id, request);
    return true;
  }
  return false;
};

/**
 * Get check-in statistics
 */
export const getCheckInStats = () => {
  const allCheckIns = getAllCheckIns();
  const completed = allCheckIns.filter(c => c.status === 'Collected').length;
  const pending = allCheckIns.filter(c => c.status === 'Pending').length;
  
  return {
    total: allCheckIns.length,
    completed,
    pending,
    completionRate: allCheckIns.length > 0 ? (completed / allCheckIns.length * 100).toFixed(2) : '0'
  };
};
